<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>テトリスミニ（HTML単体）</title>
<style>
  body {
    font-family: monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #111;
    color: #eee;
    user-select: none;
  }
  #game {
    position: relative;
    width: 200px; /* 10*20 */
    height: 400px; /* 20*20 */
    background: #222;
    border: 3px solid #555;
    margin-top: 20px;
  }
  .cell {
    width: 20px;
    height: 20px;
    box-sizing: border-box;
    border: 1px solid #333;
    float: left;
  }
  #controls {
    margin-top: 20px;
  }
  button {
    margin: 3px;
    padding: 5px 10px;
    font-size: 14px;
  }
  #status {
    margin-top: 10px;
    min-height: 20px;
  }
  #saveLoad {
    margin-top: 20px;
  }
</style>
</head>
<body>

<h1>テトリスミニ</h1>
<div id="game"></div>

<div id="controls">
  <button id="upBtn">上</button>
  <button id="leftBtn">左</button>
  <button id="downBtn">下</button>
  <button id="rightBtn">右</button>
</div>

<div>
  <button id="undoBtn">一手戻る</button>
  <button id="resetUndoBtn">すべて戻る</button>
</div>

<div id="saveLoad">
  <button id="saveBtn">保存</button>
  <button id="loadBtn">読み込み</button>
</div>

<div id="status"></div>

<script>
(() => {
  const COLS = 10;
  const ROWS = 20;
  const CELL_SIZE = 20;

  const gameEl = document.getElementById('game');
  const statusEl = document.getElementById('status');

  // テトリスのブロック形状（4x4配列）と色
  // I, J, L, O, S, T, Z の順
  const TETROMINOS = [
    { shape: [ // I
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0]
    ], color: '#00f0f0' },
    { shape: [ // J
      [1,0,0],
      [1,1,1],
      [0,0,0]
    ], color: '#0000f0' },
    { shape: [ // L
      [0,0,1],
      [1,1,1],
      [0,0,0]
    ], color: '#f0a000' },
    { shape: [ // O
      [1,1],
      [1,1]
    ], color: '#f0f000' },
    { shape: [ // S
      [0,1,1],
      [1,1,0],
      [0,0,0]
    ], color: '#00f000' },
    { shape: [ // T
      [0,1,0],
      [1,1,1],
      [0,0,0]
    ], color: '#a000f0' },
    { shape: [ // Z
      [1,1,0],
      [0,1,1],
      [0,0,0]
    ], color: '#f00000' },
  ];

  // 次に出る順は本物のテトリスは7種ランダム順の袋方式
  // 今回はシンプルに袋から順に出す実装にする（袋が空になったらまた新しい袋作る）
  let bag = [];
  function createBag() {
    bag = [0,1,2,3,4,5,6];
    // シャッフル
    for(let i=bag.length-1; i>0; i--) {
      const j = Math.floor(Math.random() * (i+1));
      [bag[i], bag[j]] = [bag[j], bag[i]];
    }
  }

  // ゲーム盤面 20行10列 0=空き、それ以外は色文字列
  let board = [];
  for(let r=0; r<ROWS; r++) {
    board[r] = Array(COLS).fill(null);
  }

  // 現在のブロック状態
  let currentPiece = null; // {type, shape, color, x, y}
  // 操作履歴 (undo用)
  let history = [];

  // HTMLのセル作成（10*20=200個）
  // float:leftで10個で改行してる
  function createBoardHtml() {
    gameEl.innerHTML = '';
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r;
        cell.dataset.c = c;
        gameEl.appendChild(cell);
      }
    }
  }

  function draw() {
    // 盤面クリア
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const idx = r*COLS + c;
        const cell = gameEl.children[idx];
        cell.style.background = board[r][c] || '#222';
      }
    }
    // 現ブロック描画（上書き）
    if(currentPiece) {
      const {shape, x, y, color} = currentPiece;
      for(let r=0; r<shape.length; r++) {
        for(let c=0; c<shape[r].length; c++) {
          if(shape[r][c]) {
            const boardR = y + r;
            const boardC = x + c;
            if(boardR>=0 && boardR<ROWS && boardC>=0 && boardC<COLS) {
              const idx = boardR*COLS + boardC;
              const cell = gameEl.children[idx];
              cell.style.background = color;
            }
          }
        }
      }
    }
  }

  // 新しいブロックをセット
  function spawnPiece() {
    if(bag.length===0) createBag();
    const type = bag.pop();
    const {shape, color} = TETROMINOS[type];
    // 初期位置は上の方真ん中寄り（x=3が多い）
    currentPiece = {
      type,
      shape,
      color,
      x: Math.floor((COLS - shape[0].length)/2),
      y: 0
    };
  }

  // 衝突判定。trueなら衝突
  function isCollide(x, y, shape) {
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const boardR = y + r;
          const boardC = x + c;
          if(boardC<0 || boardC>=COLS || boardR>=ROWS) return true;
          if(boardR>=0 && board[boardR][boardC]) return true;
        }
      }
    }
    return false;
  }

  // 現ブロックの形を回転（右回転90度）
  function rotate(shape) {
    const H = shape.length;
    const W = shape[0].length;
    let newShape = [];
    for(let c=0; c<W; c++) {
      let newRow = [];
      for(let r=H-1; r>=0; r--) {
        newRow.push(shape[r][c]);
      }
      newShape.push(newRow);
    }
    return newShape;
  }

  // ブロックを盤面に固定（落ちた扱い）
  function fixPiece() {
    const {shape, x, y, color} = currentPiece;
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const boardR = y + r;
          const boardC = x + c;
          if(boardR>=0 && boardR<ROWS && boardC>=0 && boardC<COLS) {
            board[boardR][boardC] = color;
          }
        }
      }
    }
    currentPiece = null;
  }

  // 一行揃っていたら消す（消した行は上に詰める）
  function clearLines() {
    let newBoard = [];
    let linesCleared = 0;
    for(let r=0; r<ROWS; r++) {
      if(board[r].every(cell => cell !== null)) {
        linesCleared++;
      } else {
        newBoard.push(board[r]);
      }
    }
    for(let i=0; i<linesCleared; i++) {
      newBoard.unshift(Array(COLS).fill(null));
    }
    board = newBoard;
  }

  // 移動処理（dx, dy）
  function move(dx, dy) {
    if(!currentPiece) return false;
    const nx = currentPiece.x + dx;
    const ny = currentPiece.y + dy;
    if(!isCollide(nx, ny, currentPiece.shape)) {
      saveHistory();
      currentPiece.x = nx;
      currentPiece.y = ny;
      return true;
    }
    return false;
  }

  // 回転処理
  function rotateCurrent() {
    if(!currentPiece) return false;
    const newShape = rotate(currentPiece.shape);
    if(!isCollide(currentPiece.x, currentPiece.y, newShape)) {
      saveHistory();
      currentPiece.shape = newShape;
      return true;
    }
    return false;
  }

  // ブロックを落とす（下移動）。衝突なら固定して新ブロック
  function drop() {
    if(!currentPiece) return;
    if(!move(0,1)) {
      fixPiece();
      clearLines();
      spawnPiece();
      saveHistory(true);
    }
  }

  // 操作履歴を保存（一手戻る用）
  function saveHistory(reset=false) {
    if(reset) {
      history = [];
    }
    // board, currentPiece の深いコピー
    const boardCopy = board.map(row => row.slice());
    const pieceCopy = currentPiece ? {
      type: currentPiece.type,
      shape: currentPiece.shape.map(r => r.slice()),
      color: currentPiece.color,
      x: currentPiece.x,
      y: currentPiece.y
    } : null;
    history.push({
      board: boardCopy,
      currentPiece: pieceCopy,
      bag: bag.slice()
    });
    if(history.length > 100) history.shift();
  }

  // 一手戻る
  function undo() {
    if(history.length<=1) {
      statusEl.textContent = '戻れる手がありません';
      return;
    }
    history.pop();
    const last = history[history.length-1];
    board = last.board.map(row => row.slice());
    currentPiece = last.currentPiece ? {
      type: last.currentPiece.type,
      shape: last.currentPiece.shape.map(r => r.slice()),
      color: last.currentPiece.color,
      x: last.currentPiece.x,
      y: last.currentPiece.y
    } : null;
    bag = last.bag.slice();
    statusEl.textContent = '一手戻りました';
    draw();
  }

  // すべて戻る
  function resetUndo() {
    if(history.length === 0) return;
    const first = history[0];
    board = first.board.map(row => row.slice());
    currentPiece = first.currentPiece ? {
      type: first.currentPiece.type,
      shape: first.currentPiece.shape.map(r => r.slice()),
      color: first.currentPiece.color,
      x: first.currentPiece.x,
      y: first.currentPiece.y
    } : null;
    bag = first.bag.slice();
    history = [first];
    statusEl.textContent = 'すべて戻りました';
    draw();
  }

  // 保存処理（localStorageにJSON文字列保存）
  function saveGame() {
    if(history.length === 0) {
      statusEl.textContent = '保存する状態がありません';
      return;
    }
    const last = history[history.length-1];
    localStorage.setItem('tetrisSave', JSON.stringify(last));
    statusEl.textContent = 'ゲームを保存しました';
  }

  // 読み込み処理
  function loadGame() {
    const json = localStorage.getItem('tetrisSave');
    if(!json) {
      statusEl.textContent = '保存データがありません';
      return;
    }
    try {
      const data = JSON.parse(json);
      board = data.board.map(row => row.slice());
      currentPiece = data.currentPiece ? {
        type: data.currentPiece.type,
        shape: data.currentPiece.shape.map(r => r.slice()),
        color: data.currentPiece.color,
        x: data.currentPiece.x,
        y: data.currentPiece.y
      } : null;
      bag = data.bag.slice();
      history = [data];
      statusEl.textContent = 'ゲームを読み込みました';
      draw();
    } catch(e) {
      statusEl.textContent = '読み込みエラー';
    }
  }

  // ボタンイベント登録
  function setupButtons() {
    document.getElementById('upBtn').onclick = () => {
      if(rotateCurrent()) {
        statusEl.textContent = '回転しました';
        draw();
      } else {
        statusEl.textContent = '回転できません';
      }
    };
    document.getElementById('leftBtn').onclick = () => {
      if(move(-1,0)) {
        statusEl.textContent = '左に移動しました';
        draw();
      } else {
        statusEl.textContent = '移動できません';
      }
    };
    document.getElementById('downBtn').onclick = () => {
      if(move(0,1)) {
        statusEl.textContent = '下に移動しました';
        draw();
      } else {
        statusEl.textContent = '移動できません';
      }
    };
    document.getElementById('rightBtn').onclick = () => {
      if(move(1,0)) {
        statusEl.textContent = '右に移動しました';
        draw();
      } else {
        statusEl.textContent = '移動できません';
      }
    };
    document.getElementById('undoBtn').onclick = () => {
      undo();
    };
    document.getElementById('resetUndoBtn').onclick = () => {
      resetUndo();
    };
    document.getElementById('saveBtn').onclick = () => {
      saveGame();
    };
    document.getElementById('loadBtn').onclick = () => {
      loadGame();
    };
  }

  // 初期化
  function init() {
    createBoardHtml();
    createBag();
    spawnPiece();
    saveHistory(true);
    draw();
    setupButtons();
    statusEl.textContent = 'ゲーム開始';
  }

  init();
})();
</script>

</body>
</html>
